# 냠냠코치 프로젝트

## 1. 프로젝트 개요

**'냠냠코치' 프로젝트**는 사용자의 식단 기록을 분석하여 개인 맞춤형 건강 코칭을 제공하는 서비스입니다.  
식품의약품안전처의 음식 DB와 국민건강 통계 데이터를 활용하여 사용자의 목표에 맞는 식단을 분석하고, 다양한 부가 기능을 제공합니다.

---

## 2. 목표

- 자료구조 및 알고리즘의 특성과 복잡도를 이해하고, 문제 해결에 최적의 조합을 선정합니다.
- 다양한 알고리즘 기법을 실무 시나리오에 적용하여 효율성을 극대화합니다.
- Big-O 이론 분석과 성능 테스트를 통해 시간 및 메모리 효율성을 평가하고 개선합니다.

---

## 3. 데이터 별 자료구조

### 1. 해시 테이블

- **정의**: 키(Key)와 값(Value)을 매핑하여 데이터를 저장하는 자료구조.
- **시간 복잡도**: 평균적으로 검색, 삽입, 삭제는 `O(1)`
- **단점 및 해결 방법**: 해시 충돌 발생 시 체이닝, 개방 주소법 등 충돌 해결 기법 필요.
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 식단 | 음식 ID와 식단 기록 ID를 키로 하여 빠른 접근 및 수정 가능 | 해시 충돌 및 메모리 사용량 증가 가능 |
| 회원 | 회원 ID를 키로 하여 빠른 로그인 및 데이터 접근 가능 | 해시 충돌 및 메모리 사용량 증가 가능 |

---

### 2. 배열

- **정의**: 동일한 타입의 데이터를 메모리의 연속된 공간에 저장하는 자료구조.
- **시간 복잡도**: 인덱스를 통한 접근은 `O(1)`, 중간 삽입/삭제는 뒤에 있는 모든 데이터를 이동시켜야 하므로 비효율적.
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 식단 | 날짜순 정렬로 인덱스를 통한 빠른 접근 가능 | 중간 삽입/삭제 시 성능 저하 |
| 공지사항 | 인덱스로 빠른 조회 가능 | 삭제/변경 시 인덱스 관리 필요 |

---

### 3. 그래프

- **정의**: 정점(Vertex)과 간선(Edge)으로 구성된 비선형 자료구조. DFS, BFS 알고리즘 적용 가능.
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 식단 | 영양소 간 관계 및 패턴 시각화 가능 | 구현 복잡도 및 계산 비용 높음 |

---

### 4. B-Tree

- **정의**: 다수의 키와 자식 노드를 가질 수 있는 트리 구조로, 데이터베이스 인덱싱에 적합.
- **시간 복잡도**: `O(log N)` (검색, 삽입, 삭제)
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 관리자용 회원 정보 | 대량 데이터 정렬 및 검색에 효율적 | 해시보다 느리고 삽입/삭제 시 비용 발생 |
| 관리자용 식단 기록 | 날짜순, 기간별 조회에 적합 | 구현 복잡, 메모리 사용 많음 |

---

### 5. LinkedList

- **정의**: 노드들이 포인터로 연결된 선형 자료구조.
- **시간 복잡도**: 중간 삽입/삭제 `O(1)`, 검색은 `O(N)`
<br><br>

- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 공지사항 | 빠른 추가/삭제 가능 | 검색 시 느림, 순차 탐색 필요 |

---

## 4. 기능별 알고리즘

### 4.1 필수 기능

---

### 기능 01. 식단 작성

- **문제 정의**
  - 사용자가 섭취한 음식을 DB에서 쉽게 검색하고 식단 기록에 추가할 수 있어야 한다.
- **적용 알고리즘**
  - 이진 검색 (Binary Search)
- **알고리즘 설명**
  - 정렬된 데이터에서 목표 값을 찾아내는 효율적인 탐색 알고리즘
  - 데이터의 중간 값을 선택해 목표 값과 비교하고, 목표 값의 크기에 따라 탐색 범위를 절반으로 줄여가며 찾는 방식
  - O(logN)의 시간 복잡도를 가진다.
- **알고리즘 사용 예시**
  - 100만 개 이상의 음식이 담긴 음식 DB가 음식 이름순으로 정렬되어 있을 때, 사용자가 '닭가슴살'을 검색하면 이진 검색을 통해 단 몇 번의 비교만으로 해당 정보를 빠르게 찾아낼 수 있다.
- **장점**
  - **빠른 탐색 속도:** 대용량 데이터에서 원하는 정보를 신속하게 찾을 수 있다.
  - **간단한 구현:** 비교적 쉽게 구현할 수 있다.
- **단점**
  - **데이터 정렬 필수:** 데이터가 정렬되어 있지 않으면 사용할 수 없고, 정렬 상태 유지를 위한 추가 비용이 발생한다.
  - **메모리 효율성:** 연속적인 메모리 공간을 사용해야 효율적이다.

---

### 기능 02. 식단 검색

- **문제 정의**
    - 사용자가 섭취한 음식을 DB에서 쉽게 검색할 수 있어야 한다. 사용자가 입력한 키워드와 음식명 간의 유사도를 빠르게 찾아야 한다.
- **적용 알고리즘**
  - KMP 알고리즘
- **알고리즘 설명**
  - KMP 알고리즘은 패턴 매칭에 최적화된 알고리즘으로, O(m+n)의 시간 복잡도를 가진다. (m: 키워드(패턴)의 길이, n: 음식명(텍스트)의 길이)
  - 여러 개의 검색어를 동시에 처리해야 하는 경우, 검색어를 트라이(Trie) 자료구조에 저장하여 효율을 높일 수 있다.
- **알고리즘 사용 예시**
  - 사용자가 검색창에 '김치'를 입력하면, KMP 알고리즘을 사용해 DB 내의 '김치찌개', '김치볶음밥' 등 관련 음식명을 빠르게 찾아 자동 완성으로 제시한다.
- **장점**
  - **높은 효율성:** 문자열 탐색 시 패턴을 처음부터 다시 비교할 필요가 없어 효율적이다.
  - **선형 시간 복잡도:** O(m+n)의 선형 시간 복잡도로 대규모 데이터에서도 빠른 검색이 가능하다.
- **단점**
  - **복잡한 구현:** 알고리즘 구현이 복잡하고, 패턴 전처리 과정이 필요하다.
  - **추가 메모리:** 문자열이 매우 길 경우 패턴 전처리 테이블을 위한 메모리 공간이 추가로 필요하다.

---

### 기능 03. 식단 분석

- **문제 정의**
  - 사용자의 식단 기록과 건강 목표(질병, 다이어트 등)에 따라 영양 정보를 분석하고 점수를 산출해야 한다.
  - 목표에 맞는 영양소 기준을 바탕으로 각 영양소의 섭취량을 계산하고, 종합적인 점수를 내야 한다.
- **적용 알고리즘**
  - 동적 계획법 (DP)
- **알고리즘 설명**
  - 복잡한 문제를 여러 개의 작은 하위 문제로 나누어 해결하는 알고리즘
  - 한 번 계산한 하위 문제의 결과를 저장해두고 재활용함으로써, 동일한 계산을 반복하지 않도록 해 효율성을 높인다.
- **알고리즘 사용 예시**
  - '총 500kcal 이하에서 단백질 30g, 비타민 100mg 이상을 만족하는 최적의 식단 조합을 찾아라'와 같은 복잡한 최적화 문제 해결에 사용된다.
  - 모든 가능한 조합을 일일이 계산하는 대신, 하위 문제를 점진적으로 해결해 최적의 해를 찾아간다.
- **장점**
  - **최적화 문제 해결:** 복잡한 최적화 문제를 효율적으로 해결한다.
  - **성능 향상:** 중복 계산을 줄여 성능을 크게 향상시킬 수 있다.
- **단점**
  - **잡한 설계:** 알고리즘 설계가 매우 복잡하고, 점화식을 세우는 과정이 어려울 수 있다.
  - **높은 메모리 사용량:** 중간 결과를 저장하기 위해 메모리 공간을 많이 사용한다.

---

### 기능 04. 회원 작성

- **문제 정의**
  - 새로운 회원이 가입하면 회원 정보를 가입일 순으로 정렬된 목록에 효율적으로 추가해야 한다.
- **적용 알고리즘**
  - 삽입 정렬 (Insertion Sort)
- **알고리즘 설명**
  - 데이터를 하나씩 꺼내어 이미 정렬된 부분에 삽입하는 방식으로 정렬을 수행하는 알고리즘
  - 대부분의 데이터가 이미 정렬되어 있거나 데이터 양이 적을 때 효율적이다.
- **알고리즘 사용 예시**
  - 관리자 페이지에서 회원 목록을 가입일 순으로 관리할 때, 새로운 회원이 가입하면 기존의 정렬된 회원 목록에 새로운 회원을 올바른 위치에 삽입하여 목록을 유지할 수 있다.
- **장점**
  - **간단한 구현:** 구현이 매우 간단하다.
  - **빠른 성능:** 데이터가 거의 정렬되어 있거나 데이터 양이 적을 때 빠른 성능을 보인다.
- **단점**
  - **느린 성능:** 데이터 양이 많을 경우 O(N^2)의 시간 복잡도를 가져 성능이 급격히 저하된다.
  - **비효율적 연산:** 비교 및 삽입 과정이 많아 비효율적일 수 있다.

---

### 기능 05. 회원 조회

- **문제 정의**
  - 다양한 기준으로 회원 목록을 정렬할 수 있어야 한다.
- **적용 알고리즘**
  - 퀵 정렬 또는 병합 정렬
- **알고리즘 설명**
  - 퀵 정렬(Quick Sort): '분할 정복' 방식을 이용해 기준값(pivot)을 정하고, 기준값보다 작거나 큰 값들을 분리해 정렬하는 알고리즘
  - 병합 정렬(Merge Sort): 데이터를 절반씩 나눈 후 정렬하고, 다시 합치며 정렬을 완성하는 알고리즘
  - 둘 다 O(NlogN)의 효율적인 시간 복잡도를 가진다.
- **알고리즘 사용 예시**
  - 관리자 페이지에서 회원 목록을 이름, 가입일, 최근 접속일 등 다양한 기준으로 정렬하여 보여줄 때 사용한다.
  - 1,000명 이상의 회원 목록을 정렬해야 할 때 퀵 정렬이나 병합 정렬은 효율적이다.
- **장점**
  - **대용량 데이터 처리:** 대용량 데이터 정렬에 매우 효율적이다.
  - **다양한 기준 적용:** 다양한 정렬 기준을 적용할 수 있다.
- **단점**
  - **최악의 경우 성능 저하:** 퀵 정렬은 최악의 경우 O(N^2)의 성능을 보일 수 있다.
  - **추가 메모리 필요:** 병합 정렬은 추가적인 메모리 공간이 필요하다.
  - **복잡한 구현:** 두 알고리즘 모두 구현이 상대적으로 복잡하다.

---

### 4.2 추가 기능

---

### 기능 06. 팔로우/팔로잉 기능

- **문제 정의**: 사용자 관계 탐색 및 추천
- **적용 알고리즘**: DFS / BFS / 플로이드 워셜
- **시간 복잡도**:
  - DFS/BFS: `O(N+E)`
  - 플로이드 워셜: `O(N^3)`
- **장점**: 직접 연결 탐색 및 추천 기능 구현 가능
- **단점**: 사용자 수 증가 시 계산 비용 커짐

---

### 기능 07. 식단 리뷰 댓글 관리

- **문제 정의**: 댓글 시간 순 정렬 및 계층적 표시
- **적용 알고리즘**: 병합 정렬, 퀵 정렬
- **시간 복잡도**: `O(N log N)`
- **장점**: 안정성 및 빠른 정렬 속도
- **단점**: 구현 복잡, 병합 정렬은 추가 메모리 필요

---

### 기능 08. 공지사항 조회

- **문제 정의**: 정렬된 목록에서 빠른 검색
- **적용 알고리즘**: 이진 검색 (Binary Search)
- **시간 복잡도**: `O(log N)`
- **장점**: 빠른 탐색
- **단점**: 정렬 유지 필요, 불연속적 데이터에 부적합

---

### 4.3 심화 기능

---

### 기능 09. AI 식단 분석

- **문제 정의**: AI를 통한 맞춤형 식단 분석 및 조언
- **적용 알고리즘**: 머신러닝 알고리즘 (분류, 회귀, 클러스터링 등)
- **활용**: LLM을 통한 자연어 설명, 맞춤형 예측 제공
- **장점**:
  - 개인 맞춤형 분석 가능
  - 학습을 통한 성능 향상
- **단점**:
  - 대규모 고품질 데이터 필요
  - 계산 비용 및 자원 부담
  - 해석 어려움

---

## 📌 정리

- 본 프로젝트는 자료구조 및 알고리즘을 실제 식단 분석 서비스에 적용한 사례로, 기술적인 이해와 효율성을 실무에 반영하는 데 초점을 맞추고 있습니다.
- 사용자의 건강 데이터를 기반으로 한 고도화된 분석 기능과 추천 시스템을 통해 사용자 맞춤형 서비스를 제공합니다.

# 🍽️냠냠코치 알고리즘 적용 기획서

> - 팀: A조 (이서현, 윤정아)
> - 일시: 2025-09-19

> ### 목차
> [1. 프로젝트 개요](#1-프로젝트-개요) <br>
> [2. 목표](#2-목표) <br>
> [3. 데이터별 자료구조](#3-데이터별-자료구조) <br>
> [4. 기능별 알고리즘](#4-기능별-알고리즘) <br>
> &emsp;&emsp;[4.1 필수 기능](#41-필수-기능) <br>
> &emsp;&emsp;[4.2 추가 기능](#42-추가-기능) <br>
> &emsp;&emsp;[4.3 심화 기능](#43-심화-기능) <br>

## 1. 프로젝트 개요

**'냠냠코치' 프로젝트**는 사용자의 식단 기록을 분석하여 개인 맞춤형 건강 코칭을 제공하는 서비스입니다.  
식품의약품안전처의 음식 DB와 국민건강 통계 데이터를 활용하여 사용자의 목표에 맞는 식단을 분석하고, 다양한 부가 기능을 제공합니다.

---

## 2. 목표

- 냠냠코치 프로젝트 내에 자료구조와 알고리즘을 적용하고 그에 따른 이점과 문제점을 분석
- 자료구조 및 알고리즘의 특성과 복잡도를 이해하고, 활용 가능한 알고리즘 기법을 선정
- 활용한 알고리즘의 개념, 시간 복잡도, 장/단점을 설명

---

## 3. 데이터별 자료구조

### 3.1. 해시 테이블

- **정의**: 키(Key)와 값(Value)을 매핑하여 데이터를 저장하는 자료구조
- **시간 복잡도**: 평균적으로 검색, 삽입, 삭제는 `O(1)`
- **단점 및 해결 방법**: 해시 충돌 발생 시 체이닝, 개방 주소법 등 충돌 해결 기법 필요
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 식단 | 음식 ID와 식단 기록 ID를 키로 하여 빠른 접근 및 수정 가능 | 해시 충돌 및 메모리 사용량 증가 가능 |
| 회원 | 회원 ID를 키로 하여 빠른 로그인 및 데이터 접근 가능 | 해시 충돌 및 메모리 사용량 증가 가능 |

---

### 3.2. 배열

- **정의**: 동일한 타입의 데이터를 메모리의 연속된 공간에 저장하는 자료구조
- **시간 복잡도**: 인덱스를 통한 접근은 `O(1)`, 중간 삽입/삭제는 뒤에 있는 모든 데이터를 이동시켜야 하므로 비효율적
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 식단 | 날짜순 정렬로 인덱스를 통한 빠른 접근 가능 | 중간 삽입/삭제 시 성능 저하 |
| 공지사항 | 인덱스로 빠른 조회 가능 | 삭제/변경 시 인덱스 관리 필요 |

---

### 3.3. 그래프

- **정의**: 정점(Vertex)과 간선(Edge)으로 구성된 비선형 자료구조. DFS, BFS 알고리즘 적용 가능
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 식단 | 영양소 간 관계 및 패턴 시각화 가능 | 구현 복잡도 및 계산 비용 높음 |

---

### 3.4. B-Tree

- **정의**: 다수의 키와 자식 노드를 가질 수 있는 트리 구조로, 데이터베이스 인덱싱에 적합
- **시간 복잡도**: `O(log N)` (검색, 삽입, 삭제)
<br><br>
- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 관리자용 회원 정보 | 대량 데이터 정렬 및 검색에 효율적 | 해시보다 느리고 삽입/삭제 시 비용 발생 |
| 관리자용 식단 기록 | 날짜순, 기간별 조회에 적합 | 구현 복잡, 메모리 사용 많음 |

---

### 3.5. LinkedList

- **정의**: 노드들이 포인터로 연결된 선형 자료구조
- **시간 복잡도**: 중간 삽입/삭제 `O(1)`, 검색은 `O(N)`
<br><br>

- **이 자료구조를 활용할 데이터**

| 데이터 | 장점 | 단점 |
| ------ | ---- | ---- |
| 공지사항 | 빠른 추가/삭제 가능 | 검색 시 느림, 순차 탐색 필요 |

---

## 4. 기능별 알고리즘

### 4.1 필수 기능

---

### 기능 01. 식단 작성

- **문제 정의**
  - 사용자가 섭취한 음식을 DB에서 쉽게 검색하고 식단 기록에 추가할 수 있어야 한다.
- **적용 알고리즘**
  - 이진 검색 (Binary Search)
- **알고리즘 설명**
  - 정렬된 데이터에서 목표 값을 찾아내는 효율적인 탐색 알고리즘
  - 데이터의 중간 값을 선택해 목표 값과 비교하고, 목표 값의 크기에 따라 탐색 범위를 절반으로 줄여가며 찾는 방식
  - O(logN)의 시간 복잡도를 가진다.
- **알고리즘 사용 예시**
  - 100만 개 이상의 음식이 담긴 음식 DB가 음식 이름순으로 정렬되어 있을 때, 사용자가 '닭가슴살'을 검색하면 이진 검색을 통해 단 몇 번의 비교만으로 해당 정보를 빠르게 찾아낼 수 있다.
- **장점**
  - **빠른 탐색 속도:** 대용량 데이터에서 원하는 정보를 신속하게 찾을 수 있다.
  - **간단한 구현:** 비교적 쉽게 구현할 수 있다.
- **단점**
  - **데이터 정렬 필수:** 데이터가 정렬되어 있지 않으면 사용할 수 없고, 정렬 상태 유지를 위한 추가 비용이 발생한다.
  - **메모리 효율성:** 연속적인 메모리 공간을 사용해야 효율적이다.

---

### 기능 02. 식단 검색

- **문제 정의**
    - 사용자가 섭취한 음식을 DB에서 쉽게 검색할 수 있어야 한다. 사용자가 입력한 키워드와 음식명 간의 유사도를 빠르게 찾아야 한다.
- **적용 알고리즘**
  - KMP 알고리즘
- **알고리즘 설명**
  - KMP 알고리즘은 패턴 매칭에 최적화된 알고리즘으로, O(m+n)의 시간 복잡도를 가진다. (m: 키워드(패턴)의 길이, n: 음식명(텍스트)의 길이)
  - 여러 개의 검색어를 동시에 처리해야 하는 경우, 검색어를 트라이(Trie) 자료구조에 저장하여 효율을 높일 수 있다.
- **알고리즘 사용 예시**
  - 사용자가 검색창에 '김치'를 입력하면, KMP 알고리즘을 사용해 DB 내의 '김치찌개', '김치볶음밥' 등 관련 음식명을 빠르게 찾아 자동 완성으로 제시한다.
- **장점**
  - **높은 효율성:** 문자열 탐색 시 패턴을 처음부터 다시 비교할 필요가 없어 효율적이다.
  - **선형 시간 복잡도:** O(m+n)의 선형 시간 복잡도로 대규모 데이터에서도 빠른 검색이 가능하다.
- **단점**
  - **복잡한 구현:** 알고리즘 구현이 복잡하고, 패턴 전처리 과정이 필요하다.
  - **추가 메모리:** 문자열이 매우 길 경우 패턴 전처리 테이블을 위한 메모리 공간이 추가로 필요하다.

---

### 기능 03. 식단 분석

- **문제 정의**
  - 사용자의 식단 기록과 건강 목표(질병, 다이어트 등)에 따라 영양 정보를 분석하고 점수를 산출해야 한다.
  - 목표에 맞는 영양소 기준을 바탕으로 각 영양소의 섭취량을 계산하고, 종합적인 점수를 내야 한다.
- **적용 알고리즘**
  - 동적 계획법 (DP)
- **알고리즘 설명**
  - 복잡한 문제를 여러 개의 작은 하위 문제로 나누어 해결하는 알고리즘
  - 한 번 계산한 하위 문제의 결과를 저장해두고 재활용함으로써, 동일한 계산을 반복하지 않도록 해 효율성을 높인다.
- **알고리즘 사용 예시**
  - '총 500kcal 이하에서 단백질 30g, 비타민 100mg 이상을 만족하는 최적의 식단 조합을 찾아라'와 같은 복잡한 최적화 문제 해결에 사용된다.
  - 모든 가능한 조합을 일일이 계산하는 대신, 하위 문제를 점진적으로 해결해 최적의 해를 찾아간다.
- **장점**
  - **최적화 문제 해결:** 복잡한 최적화 문제를 효율적으로 해결한다.
  - **성능 향상:** 중복 계산을 줄여 성능을 크게 향상시킬 수 있다.
- **단점**
  - **잡한 설계:** 알고리즘 설계가 매우 복잡하고, 점화식을 세우는 과정이 어려울 수 있다.
  - **높은 메모리 사용량:** 중간 결과를 저장하기 위해 메모리 공간을 많이 사용한다.

---

### 기능 04. 회원 작성

- **문제 정의**
  - 새로운 회원이 가입하면 회원 정보를 가입일 순으로 정렬된 목록에 효율적으로 추가해야 한다.
- **적용 알고리즘**
  - 삽입 정렬 (Insertion Sort)
- **알고리즘 설명**
  - 데이터를 하나씩 꺼내어 이미 정렬된 부분에 삽입하는 방식으로 정렬을 수행하는 알고리즘
  - 대부분의 데이터가 이미 정렬되어 있거나 데이터 양이 적을 때 효율적이다.
- **알고리즘 사용 예시**
  - 관리자 페이지에서 회원 목록을 가입일 순으로 관리할 때, 새로운 회원이 가입하면 기존의 정렬된 회원 목록에 새로운 회원을 올바른 위치에 삽입하여 목록을 유지할 수 있다.
- **장점**
  - **간단한 구현:** 구현이 매우 간단하다.
  - **빠른 성능:** 데이터가 거의 정렬되어 있거나 데이터 양이 적을 때 빠른 성능을 보인다.
- **단점**
  - **느린 성능:** 데이터 양이 많을 경우 O(N^2)의 시간 복잡도를 가져 성능이 급격히 저하된다.
  - **비효율적 연산:** 비교 및 삽입 과정이 많아 비효율적일 수 있다.

---

### 기능 05. 회원 조회

- **문제 정의**
  - 다양한 기준으로 회원 목록을 정렬할 수 있어야 한다.
- **적용 알고리즘**
  - 퀵 정렬 또는 병합 정렬
- **알고리즘 설명**
  - 퀵 정렬(Quick Sort): '분할 정복' 방식을 이용해 기준값(pivot)을 정하고, 기준값보다 작거나 큰 값들을 분리해 정렬하는 알고리즘
  - 병합 정렬(Merge Sort): 데이터를 절반씩 나눈 후 정렬하고, 다시 합치며 정렬을 완성하는 알고리즘
  - 둘 다 O(NlogN)의 효율적인 시간 복잡도를 가진다.
- **알고리즘 사용 예시**
  - 관리자 페이지에서 회원 목록을 이름, 가입일, 최근 접속일 등 다양한 기준으로 정렬하여 보여줄 때 사용한다.
  - 1,000명 이상의 회원 목록을 정렬해야 할 때 퀵 정렬이나 병합 정렬은 효율적이다.
- **장점**
  - **대용량 데이터 처리:** 대용량 데이터 정렬에 매우 효율적이다.
  - **다양한 기준 적용:** 다양한 정렬 기준을 적용할 수 있다.
- **단점**
  - **최악의 경우 성능 저하:** 퀵 정렬은 최악의 경우 O(N^2)의 성능을 보일 수 있다.
  - **추가 메모리 필요:** 병합 정렬은 추가적인 메모리 공간이 필요하다.
  - **복잡한 구현:** 두 알고리즘 모두 구현이 상대적으로 복잡하다.

---

### 4.2 추가 기능

---


### 기능 06. 팔로우/팔로잉 기능

- **문제 정의**
    - 사용자 간 팔로우/팔로잉 관계를 관리하고, 팔로우 목록을 조회할 수 있어야 한다.
- **적용 알고리즘**
    - DFS/BFS 또는 플로이드 워셜(Floyd-Warshall)
- **알고리즘 설명**
    - DFS(깊이 우선 탐색)는 한 방향으로 갈 수 있는 모든 경로를 끝까지 탐색하는 알고리즘
    - BFS(너비 우선 탐색)는 시작점에서 가까운 노드부터 탐색하는 알고리즘
    - 플로이드 워셜은 모든 정점 쌍 간의 최단 경로를 찾는 동적 계획법 기반의 알고리즘
- **알고리즘 사용 예시**
    - **팔로워/팔로잉 목록 조회**: 특정 사용자와 직접 연결된 팔로워 또는 팔로잉 목록을 빠르게 탐색할 수 있다.
    - **추천 기능**: '친구의 친구'와 같이 간접적인 팔로우 관계를 기반으로 사용자에게 새로운 팔로잉 대상을 추천하려면, 플로이드 워셜과 같은 최단 경로 알고리즘을 활용할 수 있다. 모든 사용자 간의 관계를 분석하여 서로에게 가장 가까운 사용자들을 찾아 추천 목록을 생성한다.
- **장점**
    - **DFS/BFS:** 사용자-팔로워 관계를 그래프로 모델링하여, 특정 사용자와 직접 연결된 팔로워/팔로잉 목록을 **효율적으로** 찾을 수 있다. 구현이 비교적 간단하다.
    - **플로이드 워셜:** 모든 사용자 간의 **간접적인 관계를 한 번에** 계산할 수 있어 추천 기능에 유용하다.
- **단점**
    - **DFS/BFS:** 그래프가 복잡할 경우, 특정 노드까지의 최단 경로를 찾는 데 비효율적일 수 있다.
    - **플로이드 워셜:** O(N^3)의 시간 복잡도를 가져, 사용자 수가 많아지면 계산 시간이 기하급수적으로 늘어난다.

---

### 기능 07. 식단 리뷰 댓글 관리

- **문제 정의**
    - 게시글에 달린 댓글을 효율적으로 관리하고, 계층적으로 표시할 수 있어야 한다.
- **적용 알고리즘**
    - 병합 정렬, 퀵 정렬
- **알고리즘 설명**
    - 게시글 ID와 댓글 ID를 기반으로 댓글을 저장하고 관리한다. 댓글의 순서를 결정할 때, 작성 시간을 기준으로 정렬하는 것이 일반적이다.
    - 병합 정렬(Merge Sort)은 O(n log n)의 시간 복잡도로 안정적인 정렬을 보장하며, 퀵 정렬(Quick Sort)은 평균적으로 O(n log n)의 빠른 속도를 보여준다.
- **알고리즘 사용 예시**
    - 사용자들이 특정 식단 게시글에 댓글을 달면, 댓글이 달린 시간을 기준으로 병합 정렬 또는 퀵 정렬을 사용해 최신순으로 정렬하여 표시한다.
    - 대댓글의 경우, 부모 댓글과 연결된 그룹으로 묶어 계층적으로 정렬할 수 있다.
- **장점**
    - **안정적인 정렬:** 병합 정렬은 댓글 작성 시간순으로 정렬할 때 동일한 시간의 댓글이라도 순서가 뒤바뀌지 않는 안정성을 제공한다.
    - **빠른 정렬 속도:** 두 알고리즘 모두 평균적으로 O(n log n)의 시간 복잡도로 대량의 댓글도 빠르게 정렬할 수 있다.
- **단점**
    - **구현 복잡성:** 두 알고리즘 모두 구현이 상대적으로 복잡하다.
    - **추가 메모리:** 병합 정렬은 정렬 과정에서 임시 배열이 필요해 추가적인 메모리를 사용한다.

---

### 기능 08. 공지사항 조회

- **문제 정의**
    - 정렬된 공지사항 목록에서 원하는 공지사항을 빠르게 찾아내는 데 사용된다.
- **적용 알고리즘**
    - 이진 검색 (Binary Search)
- **알고리즘 설명**
    - 정렬된 데이터에서 목표 값을 찾아내는 효율적인 탐색 알고리즘
    - 데이터의 중간 값을 선택하여 목표 값과 비교하고, 목표 값의 크기에 따라 탐색 범위를 절반으로 줄여가며 찾는 방식이다.
    - O(logN)의 시간 복잡도를 가진다.
- **알고리즘 사용 예시**
    - 수백 개의 공지사항이 날짜나 번호순으로 정렬되어 있을 때, 사용자가 특정 날짜나 번호의 공지사항을 찾으려 할 때 이진 검색을 사용하면 빠르게 해당 정보를 찾아낼 수 있습니다.
- **장점**
    - **빠른 탐색 속도**: 공지사항이 많아져도 성능 저하가 적다.
- **단점**
    - **정렬 시 비용 발생**: 공지사항 목록이 항상 정렬된 상태로 유지되어야 하므로, 새로운 공지사항이 추가될 때마다 정렬 비용이 발생한다.
    - 불연속적인 데이터 저장에는 부적합하다.

---

### 4.3 심화 기능

---

### 기능 09. AI 식단 분석

- **문제 정의**
    - 사용자가 입력한 식단 기록을 기반으로 생성형 AI를 활용해 심층적인 분석을 제공해야 한다. 단순히 점수를 매기는 것을 넘어, 개인의 건강 상태에 맞는 구체적인 조언을 제공해야 한다.
- **적용 알고리즘**
    - 머신러닝 알고리즘
- **알고리즘 설명**
    - 데이터를 기반으로 학습하여 패턴을 인식하고 예측을 수행하는 기술
    - 회귀(Regression), 분류(Classification), 클러스터링(Clustering) 등 다양한 기법이 포함된다. 이 기능을 위해 사용자의 식단 데이터, 활동량, 건강 정보 등을 입력으로 받아 모델을 학습시킨다.
- **알고리즘 사용 예시**
    - AI 식단 분석은 사용자의 식단 데이터를 입력으로 받아, 학습된 모델을 통해 맞춤형 분석 결과를 생성한다. 이를 위해, 다양한 데이터를 기반으로 AI 모델을 학습시켜야 한다. 이 과정에서 빅 데이터 처리 알고리즘이 활용될 수 있으며, 분석 결과는 자연어 생성 모델(LLM)을 통해 사용자가 이해하기 쉬운 형태로 변환된다.
- **장점**:
    - **개인 맞춤형 분석**: 사용자의 개인적인 특성을 고려한 심층적이고 맞춤화된 조언을 제공할 수 있다.
    - **학습을 통한 정확도 향상**: 더 많은 데이터가 쌓일수록 모델의 예측 정확도가 향상되어 더 유용한 정보를 제공할 수 있다.
- **단점**:
    - **대규모 고품질 데이터 필요**: 정확한 분석을 위해서는 방대하고 질 좋은 학습 데이터가 필수적이다.
    - **높은 계산 비용**: 모델 학습 및 운영에 고성능 컴퓨팅 자원이 필요해 비용이 많이 들 수 있다.
    - **결과 해석의 어려움**: AI가 도출한 결과를 사용자가 이해하기 쉽게 변환하는 과정이 필요하며, 때때로 예측 결과의 이유를 설명하기 어려울 수 있다.
